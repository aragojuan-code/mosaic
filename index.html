<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Laboratorio de baldosas</title>
<style>
  :root{
    --bg:#0f1115; --card:#151923; --fg:#e6e8ef; --muted:#99a1b3; --accent:#4f8cff;
    --ring:#2a3042;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--fg)}
  .wrap{max-width:1200px;margin:0 auto;padding:12px}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
  h1{font-size:18px;margin:0}
  .pill{padding:6px 10px;border-radius:999px;border:1px solid var(--ring);background:#121622;color:var(--muted);font-size:12px}

  .stage{
    background:var(--card);border:1px solid #232839;border-radius:16px;padding:10px;
    box-shadow:0 10px 30px rgba(0,0,0,.25);
    display:flex;flex-direction:column;gap:10px;
  }
  .topbar{display:flex;align-items:center;justify-content:space-between}
  .dims{font-size:12px;color:var(--muted)}

  /* Canvas separado en su wrap y con z-index bajo */
  .canvas-wrap{position:relative;z-index:1}
  canvas{
    background:#0b0e15;border:1px solid #232839;border-radius:16px;display:block;
    width:100%;height:auto;touch-action:none;position:relative;z-index:1
  }

  /* Paleta + barra vertical de iconos; forzamos z-index alto */
  .underbar{
    display:grid;grid-template-columns:1fr 44px;gap:10px;align-items:start;
    position:relative;z-index:5
  }
  .palette-grid{
    display:flex;flex-wrap:wrap;gap:8px;padding:8px;border:1px solid #232839;border-radius:12px;background:#101520
  }
  .swatch{width:28px;height:28px;border-radius:6px;border:2px solid var(--ring);cursor:pointer}
  .swatch.active{outline:2px solid var(--accent)}

  .vtools{display:flex;flex-direction:column;gap:8px;align-items:stretch;justify-content:flex-start}
  .icon-btn{
    width:44px;height:44px;display:inline-flex;align-items:center;justify-content:center;
    border:1px solid var(--ring);background:#1b2030;color:var(--fg);
    border-radius:12px;cursor:pointer;font-size:20px;pointer-events:auto;touch-action:manipulation
  }
  .icon-btn:active{transform:translateY(1px)}
  .icon-btn.active{outline:2px solid var(--accent)}

  .bottom-actions{display:flex;gap:10px;flex-wrap:wrap}
  .btn,.btn-ghost{
    appearance:none;border:1px solid var(--ring);background:#1b2030;color:var(--fg);
    padding:10px 14px;border-radius:12px;cursor:pointer;min-height:40px;font:inherit;touch-action:manipulation
  }
  .btn-ghost{background:#101522}

  @media (max-width:860px){
    .wrap{padding:10px}
    .underbar{grid-template-columns:1fr 42px}
    .icon-btn{width:42px;height:42px}
    .swatch{width:26px;height:26px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>üß± Laboratorio de baldosas</h1>
      <span id="modePill" class="pill">Igual</span>
    </header>

    <section class="stage">
      <div class="topbar">
        <span class="pill">Dibuja en la baldosa central</span>
        <span id="dims" class="dims"></span>
      </div>

      <div class="canvas-wrap">
        <canvas id="mosaic" aria-label="Mosaico"></canvas>
      </div>

      <div class="underbar">
        <div id="palette" class="palette-grid" aria-label="Colores"></div>
        <div class="vtools" aria-label="Herramientas">
          <button id="undoBtn" class="icon-btn" title="Deshacer" aria-label="Deshacer">‚Ü∂</button>
          <button id="toolPencil" class="icon-btn active" title="L√°piz" aria-label="L√°piz">‚úèÔ∏è</button>
          <button id="toolEraser" class="icon-btn" title="Goma" aria-label="Goma">üßΩ</button>
          <button id="geomBtn" class="icon-btn" title="Tipo (Cuadrado/Hex√°gono)" aria-label="Tipo">‚óªÔ∏è</button>
          <button id="modeBtn" class="icon-btn" title="Modo" aria-label="Modo">üîÑ</button>
          <button id="rotBtn" class="icon-btn active" title="Solo rotaciones" aria-label="Solo rotaciones">‚ü≥</button>
          <button id="gridBtn" class="icon-btn" title="Cuadr√≠cula" aria-label="Cuadr√≠cula">#Ô∏è‚É£</button>
        </div>
      </div>

      <div class="bottom-actions">
        <button id="clear" class="btn">Limpiar</button>
        <button id="download" class="btn-ghost">Guardar PNG</button>
      </div>
    </section>
  </div>

<script>
/* ---------- HiDPI ---------- */
function setupHiDPICanvas(canvas, cssW, cssH) {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  canvas.style.width = cssW + "px";
  canvas.style.height = cssH + "px";
  const ctx = canvas.getContext("2d");
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return ctx;
}

/* ---------- Estado ---------- */
const BG = "#0b0e15";
const COLORS = [
  "#ffffff","#000000",
  "#f6c445","#0b5fff","#d90429","#2eb872",
  "#ff7f50","#ffb6c1","#ba55d3","#8a2be2",
  "#00ced1","#1e90ff","#4169e1","#00fa9a",
  "#ffd700","#ffa500","#ff4500","#e91e63",
  "#8bc34a","#4caf50","#009688","#795548",
  "#9e9e9e","#607d8b"
];
let currentColor = COLORS[3];
let lineWidth = 8;
let gridN = 3;
const tileSize = 128;         // fijo
let tool = "pencil";          // pencil | eraser
let geometry = "square";      // square | hex
let rotOnly = true;
let viewScale = 1;            // ‚Üê √∫nica variable (no duplicada)
let mosaicCtx;

// modos
const MODES_ROT_SQ = ["Igual","Rotado 180¬∞","Rotado 90¬∞"];
const MODES_MIR_SQ = ["Espejo vertical","Espejo horizontal","Espejo ajedrez"];
const MODES_ROT_HEX = ["Igual","Rotado 180¬∞","Rotado 60¬∞"];
const MODES_MIR_HEX = ["Espejo vertical","Espejo horizontal","Espejo ajedrez"];
let modes = MODES_ROT_SQ.slice();
let modeIndex = 0;

// historial
const history = []; let historyIndex = -1;

/* ---------- DOM ---------- */
const mosaic = document.getElementById("mosaic");
const palette = document.getElementById("palette");
const undoBtn = document.getElementById("undoBtn");
const toolPencil = document.getElementById("toolPencil");
const toolEraser = document.getElementById("toolEraser");
const geomBtn = document.getElementById("geomBtn");
const modeBtn = document.getElementById("modeBtn");
const rotBtn = document.getElementById("rotBtn");
const gridBtn = document.getElementById("gridBtn");
const clearBtn = document.getElementById("clear");
const downloadBtn = document.getElementById("download");
const dimsText = document.getElementById("dims");
const modePill = document.getElementById("modePill");

/* ---------- Paleta ---------- */
function buildPalette(){
  palette.innerHTML = "";
  COLORS.forEach((c) => {
    const sw = document.createElement("button");
    sw.className = "swatch" + (c===currentColor ? " active" : "");
    sw.style.background = c;
    sw.title = c;
    sw.setAttribute("aria-label", `Color ${c}`);
    sw.addEventListener("click", () => {
      [...palette.children].forEach(el => el.classList.remove("active"));
      sw.classList.add("active");
      currentColor = c;
      tool = "pencil";
      updateToolButtons();
    });
    palette.appendChild(sw);
  });
}
function updateToolButtons(){
  toolPencil.classList.toggle("active", tool==="pencil");
  toolEraser.classList.toggle("active", tool==="eraser");
}
toolPencil.addEventListener("click", ()=>{ tool="pencil"; updateToolButtons(); });
toolEraser.addEventListener("click", ()=>{ tool="eraser"; updateToolButtons(); });

/* ---------- Iconos ---------- */
undoBtn.addEventListener("click", () => undo());

geomBtn.addEventListener("click", () => {
  geometry = (geometry === "square") ? "hex" : "square";
  geomBtn.textContent = (geometry === "square") ? "‚óªÔ∏è" : "‚¨°";
  rebuildModes(); modeIndex = 0;
  modePill.textContent = modes[modeIndex];
  initTile(); resizeAll(); render();
});

modeBtn.addEventListener("click", () => {
  modeIndex = (modeIndex + 1) % modes.length;
  modePill.textContent = modes[modeIndex];
  render();
});

rotBtn.addEventListener("click", () => {
  rotOnly = !rotOnly;
  rotBtn.classList.toggle("active", rotOnly);
  rebuildModes(); modeIndex = 0;
  modePill.textContent = modes[modeIndex];
  render();
});

const GRID_STEPS = [3,5,7,9,12];
gridBtn.addEventListener("click", () => {
  const idx = GRID_STEPS.indexOf(gridN);
  gridN = GRID_STEPS[(idx+1) % GRID_STEPS.length];
  resizeAll(); render();
});

function rebuildModes(){
  if (geometry === "square")
    modes = rotOnly ? MODES_ROT_SQ.slice() : MODES_ROT_SQ.concat(MODES_MIR_SQ);
  else
    modes = rotOnly ? MODES_ROT_HEX.slice() : MODES_ROT_HEX.concat(MODES_MIR_HEX);
}

/* ---------- Tile offscreen ---------- */
const tileCanvas = document.createElement("canvas");
const tileCtx = tileCanvas.getContext("2d", { willReadFrequently: true });

function hexPathCentered(ctx, R){
  ctx.beginPath();
  for (let i=0;i<6;i++){
    const a = i * Math.PI/3;
    const x = R * Math.cos(a), y = R * Math.sin(a);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();
}

function drawTileGuide(){
  tileCtx.save();
  tileCtx.strokeStyle = "rgba(255,255,255,.06)";
  tileCtx.lineWidth = 1;
  if (geometry === "square"){
    tileCtx.strokeRect(0.5,0.5,tileSize-1,tileSize-1);
  } else {
    tileCtx.translate(tileSize/2, tileSize/2);
    const R = tileSize/2;
    hexPathCentered(tileCtx, R);
    tileCtx.stroke();
  }
  tileCtx.restore();
}

function initTile(){
  tileCanvas.width = tileSize;
  tileCanvas.height = tileSize;
  clearTile();
  drawTileGuide();
  pushHistory(true);
}
function clearTile(){
  tileCtx.clearRect(0,0,tileSize,tileSize);
  tileCtx.fillStyle = BG;
  tileCtx.fillRect(0,0,tileSize,tileSize);
}

/* ---------- Dibujo ---------- */
let drawing=false, lastX=0, lastY=0, straight=false;

function centerRect(){
  if (geometry === "square"){
    const cx = Math.floor(gridN/2) * tileSize;
    const cy = Math.floor(gridN/2) * tileSize;
    return {x:cx,y:cy,w:tileSize,h:tileSize};
  }
  const W = gridN*tileSize, H = gridN*tileSize;
  const cx = Math.floor(W/2 - tileSize/2);
  const cy = Math.floor(H/2 - tileSize/2);
  return {x:cx,y:cy,w:tileSize,h:tileSize};
}
function inCenter(px,py){
  const c = centerRect();
  return px>=c.x && px<=c.x+c.w && py>=c.y && py<=c.y+c.h;
}
function toTileCoords(px,py){
  const c = centerRect();
  return {x:px-c.x, y:py-c.y};
}
function beginStrokeStyle(){
  tileCtx.lineWidth = lineWidth;
  tileCtx.lineCap = "round"; tileCtx.lineJoin = "round";
  if (tool === "eraser"){ tileCtx.globalCompositeOperation = "destination-out"; tileCtx.strokeStyle = "#000"; }
  else { tileCtx.globalCompositeOperation = "source-over"; tileCtx.strokeStyle = currentColor; }
}
function applyHexClipForTileCtx(){
  tileCtx.save();
  tileCtx.translate(tileSize/2, tileSize/2);
  const R = tileSize/2;
  hexPathCentered(tileCtx, R);
  tileCtx.clip();
  tileCtx.translate(-tileSize/2, -tileSize/2);
}

function getPos(e){
  const rect = mosaic.getBoundingClientRect();
  const clientX = (e.clientX ?? e.touches?.[0]?.clientX);
  const clientY = (e.clientY ?? e.touches?.[0]?.clientY);
  const x = (clientX - rect.left) / viewScale;
  const y = (clientY - rect.top) / viewScale;
  return {x,y};
}
function handlePointerDown(e){
  const pos = getPos(e);
  if (!inCenter(pos.x, pos.y)) return;
  drawing = true; straight = e.shiftKey === true;
  const {x,y} = toTileCoords(pos.x, pos.y);
  lastX = x; lastY = y;
  if (geometry === "hex") applyHexClipForTileCtx();
  beginStrokeStyle();
  tileCtx.beginPath(); tileCtx.moveTo(x,y);
  render(); e.preventDefault();
}
function handlePointerMove(e){
  if (!drawing) return;
  const pos = getPos(e);
  if (!inCenter(pos.x, pos.y)) return;
  let {x,y} = toTileCoords(pos.x, pos.y);
  if (straight){
    const dx = Math.abs(x-lastX), dy = Math.abs(y-lastY);
    if (dx>dy) y = lastY; else x = lastX;
  }
  tileCtx.lineTo(x,y); tileCtx.stroke();
  lastX = x; lastY = y;
  render(); e.preventDefault();
}
function handlePointerUp(){
  if (!drawing) return;
  drawing = false;
  tileCtx.closePath();
  if (geometry === "hex") tileCtx.restore();
  tileCtx.globalCompositeOperation = "source-over";
  pushHistory(); render();
}

/* ---------- Historial ---------- */
function pushHistory(reset=false){
  const data = tileCanvas.toDataURL("image/png");
  if (reset){ history.length = 0; historyIndex = -1; }
  history.splice(historyIndex+1);
  history.push(data); historyIndex++;
}
function restoreFrom(dataURL){
  const img = new Image();
  img.onload = () => { clearTile(); tileCtx.drawImage(img,0,0); drawTileGuide(); render(); };
  img.src = dataURL;
}
window.addEventListener("keydown",(e)=>{
  const mod = e.metaKey || e.ctrlKey;
  if (mod && e.key.toLowerCase()==="z"){ e.shiftKey ? redo() : undo(); e.preventDefault(); }
  else if (mod && e.key.toLowerCase()==="y"){ redo(); e.preventDefault(); }
});
function undo(){ if (historyIndex<=0) return; historyIndex--; restoreFrom(history[historyIndex]); }
function redo(){ if (historyIndex>=history.length-1) return; historyIndex++; restoreFrom(history[historyIndex]); }

/* ---------- Render con auto-escala ---------- */
function resizeAll(){
  const logicalW = gridN * tileSize;
  const logicalH = gridN * tileSize;
  const container = mosaic.parentElement; // .canvas-wrap
  const availW = Math.max(280, container.clientWidth);
  const availH = Math.max(240, Math.round(window.innerHeight * (window.innerWidth<860 ? 0.64 : 0.56)));
  viewScale = Math.min(availW / logicalW, availH / logicalH, 1);
  const cssW = Math.floor(logicalW * viewScale);
  const cssH = Math.floor(logicalH * viewScale);
  mosaicCtx = setupHiDPICanvas(mosaic, cssW, cssH);
  const geomTxt = geometry === 'square' ? `${gridN}√ó${gridN}` : `${gridN} filas`;
  dimsText.textContent = `${geomTxt} ¬∑ escala ${Math.round(viewScale*100)}%`;
}

function drawTileSquare(px,py, {rot=0, flipX=false, flipY=false}={}){
  const ts = tileSize;
  mosaicCtx.save();
  mosaicCtx.translate(px,py);
  if (rot){ mosaicCtx.translate(ts/2,ts/2); mosaicCtx.rotate(rot*Math.PI/180); mosaicCtx.translate(-ts/2,-ts/2); }
  if (flipX || flipY){ mosaicCtx.translate(ts/2,ts/2); mosaicCtx.scale(flipX?-1:1, flipY?-1:1); mosaicCtx.translate(-ts/2,-ts/2); }
  mosaicCtx.drawImage(tileCanvas,0,0);
  mosaicCtx.restore();
}
function drawHexAt(cx,cy,{rot=0,flipX=false,flipY=false}={}){
  const ts = tileSize, R = ts/2;
  mosaicCtx.save();
  mosaicCtx.translate(cx,cy);
  if (rot) mosaicCtx.rotate(rot*Math.PI/180);
  if (flipX || flipY) mosaicCtx.scale(flipX?-1:1, flipY?-1:1);
  hexPathCentered(mosaicCtx, R);
  mosaicCtx.clip();
  mosaicCtx.save();
  mosaicCtx.translate(-ts/2,-ts/2);
  mosaicCtx.scale(1.01,1.01);
  mosaicCtx.drawImage(tileCanvas,0,0,ts,ts);
  mosaicCtx.restore();
  mosaicCtx.restore();
}

function renderSquares(){
  const W = gridN * tileSize, H = gridN * tileSize;
  mosaicCtx.clearRect(0,0,mosaic.width,mosaic.height);
  mosaicCtx.save(); mosaicCtx.scale(viewScale, viewScale);
  mosaicCtx.fillStyle = BG; mosaicCtx.fillRect(0,0,W,H);
  const mode = modes[modeIndex];
  for (let gy=0; gy<gridN; gy++){
    for (let gx=0; gx<gridN; gx++){
      const px = gx*tileSize, py = gy*tileSize;
      if (mode === "Igual") drawTileSquare(px, py, {});
      else if (mode === "Rotado 180¬∞") drawTileSquare(px, py, { rot: ((gx+gy)%2)?180:0 });
      else if (mode === "Rotado 90¬∞")  drawTileSquare(px, py, { rot: ((gx+gy)%4)*90 });
      else if (mode === "Espejo vertical")   drawTileSquare(px, py, { flipX:(gx%2)===1 });
      else if (mode === "Espejo horizontal")  drawTileSquare(px, py, { flipY:(gy%2)===1 });
      else if (mode === "Espejo ajedrez")     drawTileSquare(px, py, { flipX:(gx%2)===1, flipY:(gy%2)===1 });
    }
  }
  mosaicCtx.strokeStyle = "rgba(255,255,255,.08)"; mosaicCtx.lineWidth = 1;
  for (let i=0;i<=gridN;i++){
    const p = i*tileSize + .5;
    mosaicCtx.beginPath(); mosaicCtx.moveTo(p,0); mosaicCtx.lineTo(p,H); mosaicCtx.stroke();
    mosaicCtx.beginPath(); mosaicCtx.moveTo(0,p); mosaicCtx.lineTo(W,p); mosaicCtx.stroke();
  }
  const c = centerRect();
  mosaicCtx.strokeStyle = "rgba(79,140,255,.9)"; mosaicCtx.lineWidth = 2;
  mosaicCtx.setLineDash([6,6]); mosaicCtx.strokeRect(c.x+1, c.y+1, c.w-2, c.h-2); mosaicCtx.setLineDash([]);
  mosaicCtx.restore();
}

function renderHex(){
  const W = gridN * tileSize, H = gridN * tileSize;
  mosaicCtx.clearRect(0,0,mosaic.width,mosaic.height);
  mosaicCtx.save(); mosaicCtx.scale(viewScale, viewScale);
  mosaicCtx.fillStyle = BG; mosaicCtx.fillRect(0,0,W,H);
  const mode = modes[modeIndex];

  const ts = tileSize, R = ts/2;
  const dx = 1.5 * R, dy = Math.sqrt(3) * R;
  const CW = gridN * tileSize, CH = gridN * tileSize;
  const originX = CW/2, originY = CH/2;

  const half = Math.floor(gridN/2);
  for (let col=-half; col<=half; col++){
    for (let row=-half; row<=half; row++){
      const cx = originX + col*dx;
      const cy = originY + row*dy + ((col & 1) ? dy/2 : 0);
      let rot=0, flipX=false, flipY=false;
      if (mode === "Rotado 180¬∞") rot = ((row+col)%2)?180:0;
      else if (mode === "Rotado 60¬∞") { let k=((row-col)%6+6)%6; rot=k*60; }
      else if (mode === "Espejo vertical") flipX = (col%2)!==0;
      else if (mode === "Espejo horizontal") flipY = (row%2)!==0;
      else if (mode === "Espejo ajedrez"){ flipX=(col%2)!==0; flipY=(row%2)!==0; }
      drawHexAt(cx, cy, {rot,flipX,flipY});
    }
  }
  mosaicCtx.strokeStyle = "rgba(79,140,255,.9)"; mosaicCtx.lineWidth = 2;
  mosaicCtx.setLineDash([6,6]); mosaicCtx.save();
  mosaicCtx.translate(originX, originY); hexPathCentered(mosaicCtx, R); mosaicCtx.stroke();
  mosaicCtx.restore(); mosaicCtx.setLineDash([]);
  mosaicCtx.restore();
}

function render(){
  if (!mosaicCtx) return;
  if (geometry === "square") renderSquares(); else renderHex();
}

/* ---------- Eventos ---------- */
mosaic.addEventListener("pointerdown", handlePointerDown);
mosaic.addEventListener("pointermove", handlePointerMove);
window.addEventListener("pointerup", handlePointerUp);
mosaic.addEventListener("touchstart", handlePointerDown, {passive:false});
mosaic.addEventListener("touchmove", handlePointerMove, {passive:false});
window.addEventListener("touchend", handlePointerUp);

clearBtn.addEventListener("click", () => { clearTile(); pushHistory(); render(); });
downloadBtn.addEventListener("click", () => {
  const link = document.createElement("a");
  link.download = `baldosas_${geometry}_${gridN}x${gridN}_${modes[modeIndex].replace(/\s+/g,'_')}.png`;
  link.href = mosaic.toDataURL("image/png");
  link.click();
});

/* ---------- Init ---------- */
function ensureUI(){
  modePill.textContent = modes[modeIndex];
  geomBtn.textContent = (geometry === "square") ? "‚óªÔ∏è" : "‚¨°";
  rotBtn.classList.toggle("active", rotOnly);
}
buildPalette();
ensureUI();
initTile();
resizeAll(); render();

let dpr = window.devicePixelRatio || 1;
window.matchMedia(`(resolution: ${dpr}dppx)`).addEventListener("change", () => { dpr = window.devicePixelRatio || 1; resizeAll(); render(); });
window.addEventListener("resize", () => { resizeAll(); render(); });
</script>
</body>
</html>
