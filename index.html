<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Laboratorio de baldosas</title>
<style>
  :root{
    --bg:#0f1115; --card:#151923; --fg:#e6e8ef; --muted:#99a1b3; --accent:#4f8cff;
    --pad:16px; --ring:#2a3042;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--fg)}
  .wrap{max-width:1200px;margin:0 auto;padding:var(--pad)}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
  h1{font-size:18px;margin:0}
  .pill{padding:6px 10px;border-radius:999px;border:1px solid var(--ring);background:#121622;color:var(--muted);font-size:12px}

  .stage{background:var(--card);border:1px solid #232839;border-radius:16px;padding:10px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .canvas-wrap{position:relative}
  canvas{background:#0b0e15;border:1px solid #232839;border-radius:16px;display:block;width:100%;height:auto;touch-action:none}
  .topbar{display:flex;align-items:center;justify-content:space-between;margin:6px 2px 10px}
  .dims{font-size:12px;color:var(--muted)}

  /* Herramientas en una fila (dos acordeones + icono deshacer a la derecha) */
  .tools{
    display:grid;
    grid-template-columns: 1fr 1fr auto;
    gap:10px;
    align-items:start;
    margin-top:12px;
  }
  details{background:var(--card);border:1px solid #232839;border-radius:12px;overflow:hidden;min-width:0}
  summary{
    list-style:none;display:flex;align-items:center;gap:8px;
    padding:10px 12px;cursor:pointer;font-size:14px
  }
  summary::-webkit-details-marker{display:none}
  .panel{padding:10px 12px;border-top:1px solid #232839;display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .label{color:var(--muted);font-size:12px;letter-spacing:.02em}
  .btn, select, .btn-ghost{
    appearance:none;border:1px solid var(--ring);background:#1b2030;color:var(--fg);
    padding:8px 12px;border-radius:10px;cursor:pointer;min-height:36px;font:inherit
  }
  .btn:active{transform:translateY(1px)}
  .btn-ghost{background:#101522;min-width:36px}
  .icon-btn{width:36px;height:36px;display:inline-flex;align-items:center;justify-content:center;font-size:18px}
  .toggle.active{outline:2px solid var(--accent)}
  input[type="range"]{width:180px}

  .palette-grid{
    display:grid; grid-template-columns: repeat(8, 28px); gap:8px;
  }
  .swatch{
    width:28px;height:28px;border-radius:6px;border:2px solid var(--ring);cursor:pointer
  }
  .swatch.active{outline:2px solid var(--accent)}
  .right-group{display:flex;gap:10px;align-items:center;justify-content:flex-end}

  .bottom-actions{margin-top:10px;display:flex;gap:10px;flex-wrap:wrap}

  @media (max-width:860px){
    :root{--pad:10px}
    .tools{grid-template-columns: 1fr 1fr auto}
    input[type="range"]{width:160px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>üß± Laboratorio de baldosas</h1>
      <span id="modePill" class="pill">Igual</span>
    </header>

    <section class="stage">
      <div class="topbar">
        <span class="pill">Dibuja en la baldosa central</span>
        <span id="dims" class="dims"></span>
      </div>
      <div class="canvas-wrap">
        <canvas id="mosaic" aria-label="Mosaico"></canvas>
      </div>

      <!-- Herramientas debajo: dos acordeones lado a lado + deshacer (icono) -->
      <div class="tools">
        <!-- GEOMETR√çA (cerrado por defecto) -->
        <details id="geoGroup">
          <summary>üìê Geometr√≠a</summary>
          <div class="panel">
            <div class="row">
              <span class="label">Tipo</span>
              <select id="geomSelect">
                <option value="square" selected>Cuadrados</option>
                <option value="hex">Hex√°gonos</option>
              </select>
            </div>
            <div class="row">
              <span class="label">Modo</span>
              <select id="modeSelect"></select>
              <label class="label" for="rotOnly">Solo rotaciones</label>
              <input id="rotOnly" type="checkbox" checked />
            </div>
            <div class="row">
              <span class="label">Cuadr√≠cula</span>
              <select id="gridSelect">
                <option value="3" selected>3 √ó 3</option>
                <option value="5">5 √ó 5</option>
                <option value="7">7 √ó 7</option>
                <option value="9">9 √ó 9</option>
                <option value="12">12 √ó 12</option>
              </select>
            </div>
          </div>
        </details>

        <!-- PINTAR (cerrado por defecto) -->
        <details id="paintGroup">
          <summary>üé® Pintar</summary>
          <div class="panel">
            <div class="row">
              <button id="toolPencil" class="btn toggle active">‚úèÔ∏è L√°piz</button>
              <button id="toolEraser" class="btn">üßΩ Goma</button>
            </div>
            <div class="row" style="width:100%">
              <span class="label">Color</span>
              <div id="palette" class="palette-grid"></div>
            </div>
            <div class="row">
              <span class="label">Grosor</span>
              <input id="size" type="range" min="1" max="40" value="8" />
              <span id="sizeVal" class="pill">8 px</span>
            </div>
          </div>
        </details>

        <!-- Deshacer (icono) -->
        <div class="right-group">
          <button id="undoBtn" class="btn-ghost icon-btn" title="Deshacer" aria-label="Deshacer">‚Ü∂</button>
        </div>
      </div>

      <!-- Debajo: Limpiar y Guardar -->
      <div class="bottom-actions">
        <button id="clear" class="btn">Limpiar</button>
        <button id="download" class="btn-ghost">Guardar PNG</button>
      </div>
    </section>
  </div>

<script>
/* ---------- HiDPI ---------- */
function setupHiDPICanvas(canvas, cssW, cssH) {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  canvas.width = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
  canvas.style.width = cssW + "px";
  canvas.style.height = cssH + "px";
  const ctx = canvas.getContext("2d");
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return ctx;
}

/* ---------- Estado ---------- */
const BG = "#0b0e15";
// Paleta ampliada (24)
const COLORS = [
  "#ffffff","#000000",
  "#f6c445","#0b5fff","#d90429","#2eb872",
  "#ff7f50","#ffb6c1","#ba55d3","#8a2be2",
  "#00ced1","#1e90ff","#4169e1","#00fa9a",
  "#ffd700","#ffa500","#ff4500","#e91e63",
  "#8bc34a","#4caf50","#009688","#795548",
  "#9e9e9e","#607d8b"
];
let currentColor = COLORS[2];
let lineWidth = 8;
let gridN = 3;              // por defecto 3√ó3
let tileSize = 128;         // fijo; no hay selector
let tool = "pencil";        // pencil | eraser
let geometry = "square";    // square | hex

const MODES_ROT_SQ = ["Igual","Rotado 180¬∞","Rotado 90¬∞"];
const MODES_MIR_SQ = ["Espejo vertical","Espejo horizontal","Espejo ajedrez"];
const MODES_ROT_HEX = ["Igual","Rotado 180¬∞","Rotado 60¬∞"];
const MODES_MIR_HEX = ["Espejo vertical","Espejo horizontal","Espejo ajedrez"];
let rotOnly = true;
let modes = MODES_ROT_SQ.slice();
let modeIndex = 0;          // "Igual"

let viewScale = 1;          // escala para que siempre quepa

// Historial
const history = []; let historyIndex = -1;

/* ---------- DOM ---------- */
const mosaic = document.getElementById("mosaic");
const gridSelect = document.getElementById("gridSelect");
const clearBtn = document.getElementById("clear");
const sizeRange = document.getElementById("size");
const sizeVal = document.getElementById("sizeVal");
const downloadBtn = document.getElementById("download");
const dimsText = document.getElementById("dims");
const modePill = document.getElementById("modePill");
const toolPencil = document.getElementById("toolPencil");
const toolEraser = document.getElementById("toolEraser");
const rotOnlyChk = document.getElementById("rotOnly");
const geomSelect = document.getElementById("geomSelect");
const undoBtn = document.getElementById("undoBtn");
const modeSelect = document.getElementById("modeSelect");
const geoGroup = document.getElementById("geoGroup");
const paintGroup = document.getElementById("paintGroup");

/* ---------- Acorde√≥n: al abrir uno, cerrar el otro; mantener lado a lado ---------- */
[geoGroup, paintGroup].forEach(d => {
  d.addEventListener("toggle", () => {
    if (d.open) {
      [geoGroup, paintGroup].forEach(o => { if (o !== d) o.open = false; });
    }
  });
});

/* ---------- Paleta ---------- */
const palette = document.getElementById("palette");
function buildPalette(){
  palette.innerHTML = "";
  COLORS.forEach((c, i) => {
    const s = document.createElement("button");
    s.className = "swatch" + (i===2 ? " active" : "");
    s.style.background = c;
    s.addEventListener("click", () => {
      [...palette.children].forEach(el => el.classList.remove("active"));
      s.classList.add("active");
      currentColor = c;
      tool = "pencil";
      toggleToolButtons();
    });
    palette.appendChild(s);
  });
}
buildPalette();

function toggleToolButtons(){
  toolPencil.classList.toggle("active", tool === "pencil");
  toolEraser.classList.toggle("active", tool === "eraser");
}
toolPencil.addEventListener("click", () => { tool="pencil"; toggleToolButtons(); });
toolEraser.addEventListener("click", () => { tool="eraser"; toggleToolButtons(); });

sizeRange.addEventListener("input", () => { lineWidth = +sizeRange.value; sizeVal.textContent = `${lineWidth} px`; });

gridSelect.value = String(gridN);
gridSelect.addEventListener("change", () => { gridN = +gridSelect.value; resizeAll(); render(); });

clearBtn.addEventListener("click", () => { clearTile(); pushHistory(); render(); });
undoBtn.addEventListener("click", () => { undo(); });

downloadBtn.addEventListener("click", () => {
  const link = document.createElement("a");
  link.download = `baldosas_${geometry}_${gridN}x${gridN}_${modes[modeIndex].replace(/\s+/g,'_')}.png`;
  link.href = mosaic.toDataURL("image/png");
  link.click();
});

/* ---------- Modo como select ---------- */
function updateModeOptions(){
  let list;
  if (geometry === "square")
    list = rotOnly ? MODES_ROT_SQ : MODES_ROT_SQ.concat(MODES_MIR_SQ);
  else
    list = rotOnly ? MODES_ROT_HEX : MODES_ROT_HEX.concat(MODES_MIR_HEX);

  modes = list;
  modeIndex = 0;
  modeSelect.innerHTML = "";
  list.forEach((m, i) => {
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = m;
    modeSelect.appendChild(opt);
  });
  modeSelect.value = "0";
  modePill.textContent = modes[0];
}
modeSelect.addEventListener("change", () => {
  modeIndex = +modeSelect.value;
  modePill.textContent = modes[modeIndex];
  render();
});

rotOnlyChk.addEventListener("change", () => {
  rotOnly = rotOnlyChk.checked;
  updateModeOptions();
  render();
});

geomSelect.addEventListener("change", () => {
  geometry = geomSelect.value;
  updateModeOptions();
  initTile();
  resizeAll();
  render();
});

/* ---------- Formas ---------- */
function hexPathCentered(ctx, R){
  ctx.beginPath();
  for (let i=0;i<6;i++){
    const a = i * Math.PI/3;
    const x = R * Math.cos(a), y = R * Math.sin(a);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();
}

/* ---------- Tile offscreen ---------- */
const tileCanvas = document.createElement("canvas");
const tileCtx = tileCanvas.getContext("2d", { willReadFrequently: true });

function drawTileGuide(){
  tileCtx.save();
  tileCtx.strokeStyle = "rgba(255,255,255,.06)";
  tileCtx.lineWidth = 1;
  if (geometry === "square"){
    tileCtx.strokeRect(0.5,0.5,tileSize-1,tileSize-1);
  } else {
    tileCtx.translate(tileSize/2, tileSize/2);
    const R = tileSize/2;
    hexPathCentered(tileCtx, R);
    tileCtx.stroke();
  }
  tileCtx.restore();
}

function initTile(){
  tileCanvas.width = tileSize;
  tileCanvas.height = tileSize;
  clearTile();
  drawTileGuide();
  pushHistory(true);
}

function clearTile(){
  tileCtx.clearRect(0,0,tileSize,tileSize);
  tileCtx.fillStyle = BG;
  tileCtx.fillRect(0,0,tileSize,tileSize);
}

/* ---------- Dibujo ---------- */
let drawing=false, lastX=0, lastY=0, straight=false;

function centerRect(){
  if (geometry === "square"){
    const cx = Math.floor(gridN/2) * tileSize;
    const cy = Math.floor(gridN/2) * tileSize;
    return {x:cx,y:cy,w:tileSize,h:tileSize};
  }
  const W = gridN*tileSize, H = gridN*tileSize;
  const cx = Math.floor(W/2 - tileSize/2);
  const cy = Math.floor(H/2 - tileSize/2);
  return {x:cx,y:cy,w:tileSize,h:tileSize};
}

function inCenter(px,py){
  const c = centerRect();
  return px>=c.x && px<=c.x+c.w && py>=c.y && py<=c.y+c.h;
}

function toTileCoords(px,py){
  const c = centerRect();
  return {x:px-c.x, y:py-c.y};
}

function beginStrokeStyle(){
  tileCtx.lineWidth = lineWidth;
  tileCtx.lineCap = "round";
  tileCtx.lineJoin = "round";
  if (tool === "eraser"){
    tileCtx.globalCompositeOperation = "destination-out";
    tileCtx.strokeStyle = "rgba(0,0,0,1)";
  } else {
    tileCtx.globalCompositeOperation = "source-over";
    tileCtx.strokeStyle = currentColor;
  }
}

function applyHexClipForTileCtx(){
  tileCtx.save();
  tileCtx.translate(tileSize/2, tileSize/2);
  const R = tileSize/2;
  hexPathCentered(tileCtx, R);
  tileCtx.clip();
  tileCtx.translate(-tileSize/2, -tileSize/2);
}

function getPos(e){
  const rect = mosaic.getBoundingClientRect();
  const clientX = (e.clientX ?? e.touches?.[0]?.clientX);
  const clientY = (e.clientY ?? e.touches?.[0]?.clientY);
  const x = (clientX - rect.left) / viewScale;
  const y = (clientY - rect.top) / viewScale;
  return {x,y};
}

function handlePointerDown(e){
  const pos = getPos(e);
  if (!inCenter(pos.x, pos.y)) return;
  drawing = true; straight = e.shiftKey === true;
  const {x,y} = toTileCoords(pos.x, pos.y);
  lastX = x; lastY = y;

  if (geometry === "hex") applyHexClipForTileCtx();
  beginStrokeStyle();
  tileCtx.beginPath();
  tileCtx.moveTo(x,y);
  render(); e.preventDefault();
}
function handlePointerMove(e){
  if (!drawing) return;
  const pos = getPos(e);
  if (!inCenter(pos.x, pos.y)) return;
  let {x,y} = toTileCoords(pos.x, pos.y);
  if (straight){
    const dx = Math.abs(x-lastX), dy = Math.abs(y-lastY);
    if (dx>dy) y = lastY; else x = lastX;
  }
  tileCtx.lineTo(x,y); tileCtx.stroke();
  lastX = x; lastY = y;
  render(); e.preventDefault();
}
function handlePointerUp(){
  if (!drawing) return;
  drawing = false;
  tileCtx.closePath();
  if (geometry === "hex") tileCtx.restore();
  tileCtx.globalCompositeOperation = "source-over";
  pushHistory();
  render();
}

/* ---------- Historial ---------- */
function pushHistory(reset=false){
  const data = tileCanvas.toDataURL("image/png");
  if (reset){ history.length = 0; historyIndex = -1; }
  history.splice(historyIndex+1);
  history.push(data);
  historyIndex++;
}
function restoreFrom(dataURL){
  const img = new Image();
  img.onload = () => { clearTile(); tileCtx.drawImage(img,0,0); drawTileGuide(); render(); };
  img.src = dataURL;
}
window.addEventListener("keydown",(e)=>{
  const mod = e.metaKey || e.ctrlKey;
  if (mod && e.key.toLowerCase()==="z"){ e.shiftKey ? redo() : undo(); e.preventDefault(); }
  else if (mod && e.key.toLowerCase()==="y"){ redo(); e.preventDefault(); }
});
function undo(){ if (historyIndex<=0) return; historyIndex--; restoreFrom(history[historyIndex]); }
function redo(){ if (historyIndex>=history.length-1) return; historyIndex++; restoreFrom(history[historyIndex]); }

/* ---------- Render con escala de ajuste ---------- */
let mosaicCtx;
function resizeAll(){
  const logicalW = gridN * tileSize;
  const logicalH = gridN * tileSize;

  const container = mosaic.parentElement;
  const availW = Math.max(280, container.clientWidth);
  const availH = Math.max(240, Math.round(window.innerHeight * (window.innerWidth<860 ? 0.70 : 0.60)));

  viewScale = Math.min(availW / logicalW, availH / logicalH, 1);

  const cssW = Math.floor(logicalW * viewScale);
  const cssH = Math.floor(logicalH * viewScale);

  mosaicCtx = setupHiDPICanvas(mosaic, cssW, cssH);
  const geomTxt = geometry === 'square' ? `${gridN}√ó${gridN}` : `${gridN} filas`;
  dimsText.textContent = `${geomTxt} ¬∑ escala ${Math.round(viewScale*100)}%`;
}

function drawTileSquare(px,py, {rot=0, flipX=false, flipY=false}={}){
  const ts = tileSize;
  mosaicCtx.save();
  mosaicCtx.translate(px,py);
  if (rot){ mosaicCtx.translate(ts/2,ts/2); mosaicCtx.rotate(rot*Math.PI/180); mosaicCtx.translate(-ts/2,-ts/2); }
  if (flipX || flipY){ mosaicCtx.translate(ts/2,ts/2); mosaicCtx.scale(flipX?-1:1, flipY?-1:1); mosaicCtx.translate(-ts/2,-ts/2); }
  mosaicCtx.drawImage(tileCanvas,0,0);
  mosaicCtx.restore();
}

function drawHexAt(cx,cy,{rot=0,flipX=false,flipY=false}={}){
  const ts = tileSize, R = ts/2;
  mosaicCtx.save();
  mosaicCtx.translate(cx,cy);
  if (rot) mosaicCtx.rotate(rot*Math.PI/180);
  if (flipX || flipY) mosaicCtx.scale(flipX?-1:1, flipY?-1:1);
  hexPathCentered(mosaicCtx, R);
  mosaicCtx.clip();
  mosaicCtx.save();
  mosaicCtx.translate(-ts/2,-ts/2);
  mosaicCtx.scale(1.01,1.01);
  mosaicCtx.drawImage(tileCanvas,0,0,ts,ts);
  mosaicCtx.restore();
  mosaicCtx.restore();
}

function renderSquares(){
  const W = gridN * tileSize, H = gridN * tileSize;

  mosaicCtx.clearRect(0,0,mosaic.width,mosaic.height);
  mosaicCtx.save();
  mosaicCtx.scale(viewScale, viewScale);

  mosaicCtx.fillStyle = BG; mosaicCtx.fillRect(0,0,W,H);
  const mode = modes[modeIndex];

  for (let gy=0; gy<gridN; gy++){
    for (let gx=0; gx<gridN; gx++){
      const px = gx*tileSize, py = gy*tileSize;
      if (mode === "Igual") {
        drawTileSquare(px, py, {});
      } else if (mode === "Rotado 180¬∞") {
        const rot = ((gx + gy) % 2) ? 180 : 0;
        drawTileSquare(px, py, { rot });
      } else if (mode === "Rotado 90¬∞") {
        const rot = ((gx + gy) % 4) * 90;
        drawTileSquare(px, py, { rot });
      } else if (mode === "Espejo vertical") {
        drawTileSquare(px, py, { flipX: (gx % 2) === 1 });
      } else if (mode === "Espejo horizontal") {
        drawTileSquare(px, py, { flipY: (gy % 2) === 1 });
      } else if (mode === "Espejo ajedrez") {
        drawTileSquare(px, py, { flipX: (gx % 2) === 1, flipY: (gy % 2) === 1 });
      }
    }
  }

  // grid + centro
  mosaicCtx.strokeStyle = "rgba(255,255,255,.08)"; mosaicCtx.lineWidth = 1;
  for (let i=0;i<=gridN;i++){
    const p = i*tileSize + .5;
    mosaicCtx.beginPath(); mosaicCtx.moveTo(p,0); mosaicCtx.lineTo(p,H); mosaicCtx.stroke();
    mosaicCtx.beginPath(); mosaicCtx.moveTo(0,p); mosaicCtx.lineTo(W,p); mosaicCtx.stroke();
  }
  const c = centerRect();
  mosaicCtx.strokeStyle = "rgba(79,140,255,.9)";
  mosaicCtx.lineWidth = 2;
  mosaicCtx.setLineDash([6,6]);
  mosaicCtx.strokeRect(c.x+1, c.y+1, c.w-2, c.h-2);
  mosaicCtx.setLineDash([]);

  mosaicCtx.restore();
}

function renderHex(){
  const W = gridN * tileSize, H = gridN * tileSize;

  mosaicCtx.clearRect(0,0,mosaic.width,mosaic.height);
  mosaicCtx.save();
  mosaicCtx.scale(viewScale, viewScale);

  mosaicCtx.fillStyle = BG; mosaicCtx.fillRect(0,0,W,H);
  const mode = modes[modeIndex];

  const ts = tileSize, R = ts/2;
  const dx = 1.5 * R;
  const dy = Math.sqrt(3) * R;

  const CW = gridN * tileSize, CH = gridN * tileSize;
  const originX = CW/2, originY = CH/2;

  const half = Math.floor(gridN/2);
  for (let col=-half; col<=half; col++){
    for (let row=-half; row<=half; row++){
      const cx = originX + col*dx;
      const cy = originY + row*dy + ((col & 1) ? dy/2 : 0);

      let rot=0, flipX=false, flipY=false;
      if (mode === "Rotado 180¬∞") rot = ((row+col)%2)?180:0;
      else if (mode === "Rotado 60¬∞") { let k=((row-col)%6+6)%6; rot=k*60; }
      else if (mode === "Espejo vertical") flipX = (col%2)!==0;
      else if (mode === "Espejo horizontal") flipY = (row%2)!==0;
      else if (mode === "Espejo ajedrez"){ flipX=(col%2)!==0; flipY=(row%2)!==0; }

      drawHexAt(cx, cy, {rot,flipX,flipY});
    }
  }

  // gu√≠a hex central
  mosaicCtx.strokeStyle = "rgba(79,140,255,.9)";
  mosaicCtx.lineWidth = 2;
  mosaicCtx.setLineDash([6,6]);
  mosaicCtx.save();
  mosaicCtx.translate(originX, originY);
  hexPathCentered(mosaicCtx, R);
  mosaicCtx.stroke();
  mosaicCtx.restore();
  mosaicCtx.setLineDash([]);

  mosaicCtx.restore();
}

function render(){
  if (!mosaicCtx) return;
  if (geometry === "square") renderSquares();
  else renderHex();
}

/* ---------- Puntero ---------- */
mosaic.addEventListener("pointerdown", handlePointerDown);
mosaic.addEventListener("pointermove", handlePointerMove);
window.addEventListener("pointerup", handlePointerUp);
mosaic.addEventListener("touchstart", handlePointerDown, {passive:false});
mosaic.addEventListener("touchmove", handlePointerMove, {passive:false});
window.addEventListener("touchend", handlePointerUp);

/* ---------- Init ---------- */
function ensureUI(){ sizeVal.textContent = `${lineWidth} px`; }
ensureUI();
updateModeOptions();
initTile();
resizeAll(); render();

// Reajustes en DPR/size
let dpr = window.devicePixelRatio || 1;
window.matchMedia(`(resolution: ${dpr}dppx)`).addEventListener("change", () => { dpr = window.devicePixelRatio || 1; resizeAll(); render(); });
window.addEventListener("resize", () => { resizeAll(); render(); });
</script>
</body>
</html>
